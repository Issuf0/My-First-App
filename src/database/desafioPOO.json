[
    {
        "id": 1,
        "nivel": "intermediario",
        "categoria": "poo",
        "titulo": "Classe e Objeto",
        "descricao": "Crie uma classe 'Carro' com atributos 'marca', 'modelo' e 'ano'. Crie um objeto dessa classe e imprima seus atributos.",
        "dicas": ["Defina a classe Carro", "Crie um construtor para inicializar os atributos", "Instancie o objeto com 'new Carro(...)'"],
        "variaveisObrigatorias": ["Carro meuCarro"],
        "palavrasChave": ["class", "new", "constructor", "objeto"],
        "templateCodigo": "public class Garagem {\n    static class Carro {\n        // Atributos\n        \n        // Construtor\n        \n    }\n\n    public static void main(String[] args) {\n        // Crie um objeto Carro e imprima seus dados\n        \n    }\n}",
        "pontos": 50
    },
    {
        "id": 2,
        "nivel": "intermediario",
        "categoria": "poo",
        "titulo": "Herança",
        "descricao": "Crie uma classe 'Animal' com um método 'fazerSom()'. Crie uma classe 'Cachorro' que herda de 'Animal' e sobrescreva o método 'fazerSom()' para imprimir 'Au Au!'.",
        "dicas": ["Use a palavra-chave 'extends' para herança", "Use a anotação '@Override' para sobrescrever o método", "Crie um objeto 'Cachorro' e chame o método 'fazerSom()'"],
        "variaveisObrigatorias": ["Cachorro meuCachorro"],
        "palavrasChave": ["class", "extends", "super", "@Override", "heranca"],
        "templateCodigo": "class Animal {\n    public void fazerSom() {\n        System.out.println(\"Animal fazendo som\");\n    }\n}\n\n// Crie a classe Cachorro aqui\n\npublic class TesteHeranca {\n    public static void main(String[] args) {\n        // Crie um objeto Cachorro e chame o método\n        \n    }\n}",
        "pontos": 65
    },
    {
        "id": 3,
        "nivel": "avancado",
        "categoria": "poo",
        "titulo": "Encapsulamento",
        "descricao": "Crie uma classe 'ContaBancaria' com um saldo privado. Use métodos 'depositar()' e 'getSaldo()' para modificar e acessar o saldo. Não permita depósitos de valores negativos.",
        "dicas": ["Declare o saldo como 'private'", "Crie métodos 'public' para depositar e obter o saldo", "Adicione uma verificação 'if' no método 'depositar()'"],
        "variaveisObrigatorias": ["ContaBancaria minhaConta", "private double saldo"],
        "palavrasChave": ["private", "public", "get", "set", "encapsulamento"],
        "templateCodigo": "public class Banco {\n    static class ContaBancaria {\n        // Atributo privado\n\n        // Construtor\n\n        // Método para depositar\n\n        // Método para obter saldo\n    }\n\n    public static void main(String[] args) {\n        ContaBancaria conta = new ContaBancaria(100.0);\n        conta.depositar(50);\n        // Tente depositar -20\n        System.out.println(conta.getSaldo());\n    }\n}",
        "pontos": 75
    },
    {
        "id": 4,
        "nivel": "avancado",
        "categoria": "poo",
        "titulo": "Polimorfismo",
        "descricao": "Crie uma interface 'Forma' com um método 'calcularArea()'. Implemente as classes 'Circulo' e 'Quadrado' que implementam esta interface e seus métodos.",
        "dicas": ["Use a palavra-chave 'interface'", "Use 'implements' nas classes", "A área do círculo é PI * raio * raio", "A área do quadrado é lado * lado"],
        "variaveisObrigatorias": ["Forma circulo", "Forma quadrado"],
        "palavrasChave": ["interface", "implements", "polimorfismo", "Math.PI"],
        "templateCodigo": "interface Forma {\n    double calcularArea();\n}\n\n// Implemente as classes Circulo e Quadrado aqui\n\npublic class TesteFormas {\n    public static void main(String[] args) {\n        Forma f1 = new Circulo(5.0);\n        Forma f2 = new Quadrado(4.0);\n        System.out.println(\"Área do Círculo: \" + f1.calcularArea());\n        System.out.println(\"Área do Quadrado: \" + f2.calcularArea());\n    }\n}",
        "pontos": 85
    },
    {
        "id": 5,
        "nivel": "intermediario",
        "categoria": "poo",
        "titulo": "Sobrecarga de Métodos",
        "descricao": "Crie uma classe 'Calculadora' com dois métodos 'somar', um para somar dois inteiros e outro para somar dois doubles.",
        "dicas": ["Os métodos devem ter o mesmo nome", "As assinaturas (parâmetros) devem ser diferentes", "Um retorna int, o outro retorna double"],
        "variaveisObrigatorias": ["int somar(int, int)", "double somar(double, double)"],
        "palavrasChave": ["sobrecarga", "overloading", "assinatura"],
        "templateCodigo": "public class Calculadora {\n    // Método somar para inteiros\n\n    // Método somar para doubles\n\n    public static void main(String[] args) {\n        Calculadora calc = new Calculadora();\n        System.out.println(calc.somar(5, 3));\n        System.out.println(calc.somar(5.5, 3.2));\n    }\n}",
        "pontos": 90
    },
    {
        "id": 6,
        "nivel": "intermediario",
        "categoria": "poo",
        "titulo": "Membros Estáticos",
        "descricao": "Crie uma classe 'Contador' com um atributo estático 'instancias' que incrementa a cada novo objeto criado. Adicione um método estático para obter o número de instâncias.",
        "dicas": ["Use a palavra-chave 'static' para o atributo e o método", "Incremente o contador no construtor", "O método estático é chamado a partir da classe: Contador.getInstancias()"],
        "variaveisObrigatorias": ["static int instancias", "static int getInstancias()"],
        "palavrasChave": ["static", "construtor", "classe"],
        "templateCodigo": "public class Contador {\n    // Atributo estático\n\n    public Contador() {\n        // Incrementar o contador\n    }\n\n    // Método estático\n\n    public static void main(String[] args) {\n        new Contador();\n        new Contador();\n        System.out.println(Contador.getInstancias()); // Deve imprimir 2\n    }\n}",
        "pontos": 95
    },
    {
        "id": 7,
        "nivel": "avancado",
        "categoria": "poo",
        "titulo": "Classe Abstrata",
        "descricao": "Crie uma classe abstrata 'Funcionario' com um método abstrato 'calcularSalario()'. Crie as classes 'Gerente' e 'Programador' que herdam de Funcionario e implementam o método.",
        "dicas": ["Use 'abstract class' e 'abstract void'", "Classes concretas devem usar 'extends' e implementar o método", "Classes abstratas não podem ser instanciadas"],
        "variaveisObrigatorias": ["abstract class Funcionario", "abstract double calcularSalario()"],
        "palavrasChave": ["abstract", "extends", "implementar"],
        "templateCodigo": "abstract class Funcionario {\n    public abstract double calcularSalario();\n}\n\n// Crie as classes Gerente e Programador aqui\n\npublic class TesteFuncionarios {\n    public static void main(String[] args) {\n        Funcionario g = new Gerente();\n        Funcionario p = new Programador();\n        System.out.println(g.calcularSalario());\n        System.out.println(p.calcularSalario());\n    }\n}",
        "pontos": 100
    },
    {
        "id": 8,
        "nivel": "avancado",
        "categoria": "poo",
        "titulo": "Palavra-chave final",
        "descricao": "Crie uma classe 'Configuracao' com uma constante 'URL_BANCO_DE_DADOS' (final) e um método 'conectar()' que não pode ser sobrescrito (final).",
        "dicas": ["Use 'public static final String ...' para constantes", "Use 'public final void ...' para métodos que não podem ser sobrescritos"],
        "variaveisObrigatorias": ["final String URL_BANCO_DE_DADOS", "final void conectar()"],
        "palavrasChave": ["final", "constante", "sobrescrita"],
        "templateCodigo": "public class Configuracao {\n    // Crie a constante final aqui\n\n    // Crie o método final aqui\n\n}",
        "pontos": 105
    },
    {
        "id": 9,
        "nivel": "avancado",
        "categoria": "poo",
        "titulo": "Composição",
        "descricao": "Crie uma classe 'Motor'. Crie uma classe 'Carro' que tem um 'Motor' (composição). O Carro deve ter um método para ligar o motor.",
        "dicas": ["A classe Carro deve ter um atributo do tipo Motor", "Instancie o Motor dentro do construtor do Carro", "O método do Carro chama um método do Motor"],
        "variaveisObrigatorias": ["Motor motor", "Carro carro"],
        "palavrasChave": ["composição", "tem-um", "objeto"],
        "templateCodigo": "class Motor {\n    public void ligar() {\n        System.out.println(\"Motor ligado!\");\n    }\n}\n\nclass Carro {\n    // Atributo de composição\n\n    public Carro() {\n        // Instancie o motor\n    }\n\n    // Método para ligar o motor\n}\n\npublic class TesteComposicao {\n    public static void main(String[] args) {\n        Carro meuCarro = new Carro();\n        meuCarro.ligarMotor();\n    }\n}",
        "pontos": 110
    },
    {
        "id": 10,
        "nivel": "intermediario",
        "categoria": "poo",
        "titulo": "Enumeração",
        "descricao": "Crie uma enumeração 'Naipe' para um baralho (PAUS, OUROS, COPAS, ESPADAS) com um atributo para a cor (preto ou vermelho).",
        "dicas": ["Use 'public enum Naipe { ... }'", "Adicione um construtor e um atributo à enumeração", "Os valores da enum são definidos como: COPAS(\"vermelho\")"],
        "variaveisObrigatorias": ["enum Naipe", "String cor"],
        "palavrasChave": ["enum", "constantes", "atributo"],
        "templateCodigo": "public enum Naipe {\n    // Defina os naipes e suas cores aqui\n\n    private final String cor;\n\n    Naipe(String cor) {\n        this.cor = cor;\n    }\n\n    public String getCor() {\n        return cor;\n    }\n}\n\npublic class TesteEnum {\n    public static void main(String[] args) {\n        System.out.println(Naipe.COPAS.getCor()); // Deve imprimir vermelho\n    }\n}",
        "pontos": 90
    },
    {
        "id": 11,
        "nivel": "avancado",
        "categoria": "poo",
        "titulo": "Herança com Interfaces",
        "descricao": "Crie uma classe 'Pato' que herda de 'Animal' e implementa as interfaces 'Voador' e 'Nadador'.",
        "dicas": ["Uma classe pode herdar de uma classe e implementar múltiplas interfaces", "Use 'extends Animal implements Voador, Nadador'"],
        "variaveisObrigatorias": ["extends Animal", "implements Voador, Nadador"],
        "palavrasChave": ["herança", "interface", "múltipla"],
        "templateCodigo": "class Animal { }\ninterface Voador { void voar(); }\ninterface Nadador { void nadar(); }\n\n// Crie a classe Pato aqui\n\npublic class TestePato {\n    public static void main(String[] args) {\n        Pato p = new Pato();\n        p.voar();\n        p.nadar();\n    }\n}",
        "pontos": 115
    },
    {
        "id": 12,
        "nivel": "mestre",
        "categoria": "poo",
        "titulo": "Padrão Singleton",
        "descricao": "Implemente o padrão Singleton para uma classe 'GerenciadorDeConexao', garantindo que apenas uma instância da classe possa ser criada.",
        "dicas": ["Crie um construtor privado", "Crie um atributo estático privado para a única instância", "Crie um método estático público para obter a instância"],
        "variaveisObrigatorias": ["private static GerenciadorDeConexao instancia", "private GerenciadorDeConexao()", "public static GerenciadorDeConexao getInstancia()"],
        "palavrasChave": ["singleton", "padrão de projeto", "instância única"],
        "templateCodigo": "public class GerenciadorDeConexao {\n    // Atributo estático para a instância\n\n    // Construtor privado\n\n    // Método público para obter a instância\n\n}\n\npublic class TesteSingleton {\n    public static void main(String[] args) {\n        GerenciadorDeConexao con1 = GerenciadorDeConexao.getInstancia();\n        GerenciadorDeConexao con2 = GerenciadorDeConexao.getInstancia();\n        System.out.println(con1 == con2); // Deve imprimir true\n    }\n}",
        "pontos": 125
    },
    {
        "id": 13,
        "nivel": "intermediario",
        "categoria": "poo",
        "titulo": "Sobrescrita do toString()",
        "descricao": "Na classe 'Carro' do exercício 1, sobrescreva o método toString() para retornar uma representação em string do objeto (ex: \"Marca: Ford, Modelo: Ka, Ano: 2020\").",
        "dicas": ["Use a anotação @Override", "O método deve ter a assinatura 'public String toString()'", "Concatene os atributos para formar a string de retorno"],
        "variaveisObrigatorias": ["@Override", "public String toString()"],
        "palavrasChave": ["toString", "sobrescrita", "representação"],
        "templateCodigo": "public class Carro {\n    String marca, modelo;\n    int ano;\n\n    public Carro(String marca, String modelo, int ano) {\n        this.marca = marca;\n        this.modelo = modelo;\n        this.ano = ano;\n    }\n\n    // Sobrescreva o método toString() aqui\n\n    public static void main(String[] args) {\n        Carro meuCarro = new Carro(\"Ford\", \"Ka\", 2020);\n        System.out.println(meuCarro);\n    }\n}",
        "pontos": 95
    },
    {
        "id": 14,
        "nivel": "avancado",
        "categoria": "poo",
        "titulo": "instanceof com Polimorfismo",
        "descricao": "Em um array de 'Forma' (exercício 4), use 'instanceof' para contar quantos Círculos e quantos Quadrados existem no array.",
        "dicas": ["Percorra o array com um loop for-each", "Use 'if (forma instanceof Circulo)' para verificar o tipo", "Incremente contadores separados para cada tipo"],
        "variaveisObrigatorias": ["instanceof Circulo", "instanceof Quadrado"],
        "palavrasChave": ["instanceof", "polimorfismo", "casting"],
        "templateCodigo": "interface Forma { }\nclass Circulo implements Forma { }\nclass Quadrado implements Forma { }\n\npublic class ContadorDeFormas {\n    public static void main(String[] args) {\n        Forma[] formas = {new Circulo(), new Quadrado(), new Circulo()};\n        int numCirculos = 0;\n        int numQuadrados = 0;\n\n        // Use instanceof para contar as formas\n\n        System.out.println(\"Círculos: \" + numCirculos);\n        System.out.println(\"Quadrados: \" + numQuadrados);\n    }\n}",
        "pontos": 110
    },
    {
        "id": 15,
        "nivel": "intermediario",
        "categoria": "poo",
        "titulo": "Herança e Construtores",
        "descricao": "Crie uma classe 'Veiculo' com construtor que aceita uma 'marca'. Crie uma classe 'Carro' que herda de 'Veiculo' e chama o construtor da superclasse usando 'super()'.",
        "dicas": ["O construtor da subclasse deve ser o primeiro a chamar 'super(...)'", "Passe os parâmetros necessários para o construtor da superclasse"],
        "variaveisObrigatorias": ["super(marca)", "extends Veiculo"],
        "palavrasChave": ["herança", "super", "construtor", "subclasse"],
        "templateCodigo": "class Veiculo {\n    String marca;\n    public Veiculo(String marca) {\n        this.marca = marca;\n        System.out.println(\"Construtor Veiculo: \" + marca);\n    }\n}\n\nclass Carro extends Veiculo {\n    public Carro(String marca) {\n        // Chame o construtor da superclasse aqui\n    }\n}\n\npublic class TesteSuper {\n    public static void main(String[] args) {\n        new Carro(\"Toyota\");\n    }\n}",
        "pontos": 70
    },
    {
        "id": 16,
        "nivel": "avancado",
        "categoria": "poo",
        "titulo": "Interface com Métodos Default",
        "descricao": "Crie uma interface 'Autenticavel' com um método 'autenticar(String senha)' e um método 'default void logout()' que imprime 'Logout efetuado'.",
        "dicas": ["Métodos 'default' em interfaces têm uma implementação padrão", "Uma classe que implementa a interface não precisa implementar o método default"],
        "variaveisObrigatorias": ["interface Autenticavel", "default void logout()"],
        "palavrasChave": ["interface", "default method", "Java 8"],
        "templateCodigo": "interface Autenticavel {\n    boolean autenticar(String senha);\n    // Crie o método default aqui\n}\n\nclass Usuario implements Autenticavel {\n    public boolean autenticar(String senha) {\n        return senha.equals(\"123\");\n    }\n}\n\npublic class TesteDefault {\n    public static void main(String[] args) {\n        Usuario user = new Usuario();\n        user.logout();\n    }\n}",
        "pontos": 120
    },
    {
        "id": 17,
        "nivel": "avancado",
        "categoria": "excecoes",
        "titulo": "Bloco Finally",
        "descricao": "Use um bloco 'try-catch-finally' para ler um arquivo. O bloco 'finally' deve garantir que o recurso (ex: Scanner) seja fechado, ocorrendo uma exceção ou não.",
        "dicas": ["O bloco 'finally' é sempre executado após o 'try' (e 'catch', se houver)", "É o local ideal para liberar recursos e evitar memory leaks", "Verifique se o recurso não é nulo antes de fechá-lo"],
        "variaveisObrigatorias": ["try", "catch", "finally", "close()"],
        "palavrasChave": ["finally", "exceções", "recursos", "try-with-resources"],
        "templateCodigo": "import java.util.Scanner;\nimport java.io.File;\n\npublic class BlocoFinally {\n    public static void main(String[] args) {\n        Scanner sc = null;\n        try {\n            sc = new Scanner(new File(\"inexistente.txt\"));\n        } catch (Exception e) {\n            System.out.println(\"Exceção capturada!\");\n        } finally {\n            // Feche o scanner aqui\n            System.out.println(\"Bloco finally executado.\");\n        }\n    }\n}",
        "pontos": 100
    },
    {
        "id": 18,
        "nivel": "avancado",
        "categoria": "generics",
        "titulo": "Classe Genérica",
        "descricao": "Crie uma classe genérica 'Caixa<T>' que pode armazenar um objeto de qualquer tipo. Adicione métodos 'get()' e 'set()' para o objeto.",
        "dicas": ["Use '<T>' após o nome da classe para indicar um tipo genérico", "Use 'T' como o tipo do atributo interno", "Instancie a caixa com um tipo específico: Caixa<String> caixaDeTexto = new Caixa<>();"],
        "variaveisObrigatorias": ["class Caixa<T>", "T item", "T get()", "void set(T item)"],
        "palavrasChave": ["generics", "tipo genérico", "type safety", "<T>"],
        "templateCodigo": "class Caixa<T> {\n    // Atributo e métodos genéricos aqui\n}\n\npublic class TesteCaixa {\n    public static void main(String[] args) {\n        Caixa<Integer> caixaDeInteiro = new Caixa<>();\n        caixaDeInteiro.set(10);\n        System.out.println(caixaDeInteiro.get());\n    }\n}",
        "pontos": 130
    },
    {
        "id": 19,
        "nivel": "mestre",
        "categoria": "poo",
        "titulo": "Padrão Factory",
        "descricao": "Implemente um padrão de projeto 'Factory' simples. Crie uma classe 'FabricaDeAnimal' com um método que retorna objetos 'Cachorro' ou 'Gato' (que herdam de 'Animal') baseado em uma string.",
        "dicas": ["Crie uma classe abstrata 'Animal'", "Crie as subclasses 'Cachorro' e 'Gato'", "O método da fábrica (ex: 'getAnimal(String tipo)') usa 'if' ou 'switch' para decidir qual objeto instanciar"],
        "variaveisObrigatorias": ["FabricaDeAnimal", "getAnimal(String tipo)"],
        "palavrasChave": ["factory", "padrão de projeto", "design pattern", "abstração"],
        "templateCodigo": "abstract class Animal { abstract void fazerSom(); }\nclass Cachorro extends Animal { void fazerSom() { System.out.println(\"Au Au!\"); } }\nclass Gato extends Animal { void fazerSom() { System.out.println(\"Miau!\"); } }\n\nclass FabricaDeAnimal {\n    // Implemente o método getAnimal aqui\n}\n\npublic class TesteFabrica {\n    public static void main(String[] args) {\n        FabricaDeAnimal fabrica = new FabricaDeAnimal();\n        Animal a1 = fabrica.getAnimal(\"cachorro\");\n        a1.fazerSom();\n    }\n}",
        "pontos": 140
    },
    {
        "id": 20,
        "nivel": "mestre",
        "categoria": "lambda",
        "titulo": "Expressões Lambda",
        "descricao": "Use uma expressão lambda para ordenar uma lista de Strings em ordem de tamanho (do menor para o maior).",
        "dicas": ["Use 'Collections.sort()' ou 'List.sort()'", "O segundo argumento é um 'Comparator', que pode ser uma expressão lambda", "A lambda deve comparar o 'length()' de duas strings: (s1, s2) -> Integer.compare(s1.length(), s2.length())"],
        "variaveisObrigatorias": ["List<String> nomes", "nomes.sort()"],
        "palavrasChave": ["lambda", "expressão lambda", "Comparator", "sort"],
        "templateCodigo": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class OrdenarComLambda {\n    public static void main(String[] args) {\n        List<String> nomes = new ArrayList<>(Arrays.asList(\"Ana\", \"Carlos\", \"Bia\"));\n        // Ordene a lista usando uma expressão lambda\n        \n        System.out.println(nomes);\n    }\n}",
        "pontos": 150
    },
    {
        "id": 21,
        "nivel": "mestre",
        "categoria": "reflection",
        "titulo": "Reflection API",
        "descricao": "Use a Reflection API para listar todos os nomes dos métodos da classe 'String'.",
        "dicas": ["Obtenha o objeto Class: 'String.class' ou '\"texto\".getClass()'", "Use o método 'getMethods()' para obter um array de objetos 'Method'", "Percorra o array e imprima o nome de cada método com 'method.getName()'"],
        "variaveisObrigatorias": ["String.class", "Method[] metodos", "method.getName()"],
        "palavrasChave": ["reflection", "meta-programação", "Method", "Class"],
        "templateCodigo": "import java.lang.reflect.Method;\n\npublic class InspecionarClasse {\n    public static void main(String[] args) {\n        // Use reflection para listar os métodos da classe String\n        \n    }\n}",
        "pontos": 160
    }
]