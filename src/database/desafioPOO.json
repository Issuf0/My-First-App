[
    {
        "id": 1,
        "nivel": "intermediario",
        "categoria": "poo",
        "titulo": "Classe e Objeto",
        "descricao": "Crie uma classe 'Carro' com atributos 'marca', 'modelo' e 'ano'. Crie um objeto dessa classe e imprima seus atributos.",
        "dicas": ["Defina a classe Carro", "Crie um construtor para inicializar os atributos", "Instancie o objeto com 'new Carro(...)'"],
        "variaveisObrigatorias": ["Carro meuCarro"],
        "palavrasChave": ["class", "new", "constructor", "objeto"],
        "templateCodigo": "public class Garagem {\n    static class Carro {\n        // Atributos\n        \n        // Construtor\n        \n    }\n\n    public static void main(String[] args) {\n        // Crie um objeto Carro e imprima seus dados\n        \n    }\n}",
        "pontos": 50
    },
    {
        "id": 2,
        "nivel": "intermediario",
        "categoria": "poo",
        "titulo": "Herança",
        "descricao": "Crie uma classe 'Animal' com um método 'fazerSom()'. Crie uma classe 'Cachorro' que herda de 'Animal' e sobrescreva o método 'fazerSom()' para imprimir 'Au Au!'.",
        "dicas": ["Use a palavra-chave 'extends' para herança", "Use a anotação '@Override' para sobrescrever o método", "Crie um objeto 'Cachorro' e chame o método 'fazerSom()'"],
        "variaveisObrigatorias": ["Cachorro meuCachorro"],
        "palavrasChave": ["class", "extends", "super", "@Override", "heranca"],
        "templateCodigo": "class Animal {\n    public void fazerSom() {\n        System.out.println(\"Animal fazendo som\");\n    }\n}\n\n// Crie a classe Cachorro aqui\n\npublic class TesteHeranca {\n    public static void main(String[] args) {\n        // Crie um objeto Cachorro e chame o método\n        \n    }\n}",
        "pontos": 65
    },
    {
        "id": 3,
        "nivel": "avancado",
        "categoria": "poo",
        "titulo": "Encapsulamento",
        "descricao": "Crie uma classe 'ContaBancaria' com um saldo privado. Use métodos 'depositar()' e 'getSaldo()' para modificar e acessar o saldo. Não permita depósitos de valores negativos.",
        "dicas": ["Declare o saldo como 'private'", "Crie métodos 'public' para depositar e obter o saldo", "Adicione uma verificação 'if' no método 'depositar()'"],
        "variaveisObrigatorias": ["ContaBancaria minhaConta", "private double saldo"],
        "palavrasChave": ["private", "public", "get", "set", "encapsulamento"],
        "templateCodigo": "public class Banco {\n    static class ContaBancaria {\n        // Atributo privado\n\n        // Construtor\n\n        // Método para depositar\n\n        // Método para obter saldo\n    }\n\n    public static void main(String[] args) {\n        ContaBancaria conta = new ContaBancaria(100.0);\n        conta.depositar(50);\n        // Tente depositar -20\n        System.out.println(conta.getSaldo());\n    }\n}",
        "pontos": 75
    },
    {
        "id": 4,
        "nivel": "avancado",
        "categoria": "poo",
        "titulo": "Polimorfismo",
        "descricao": "Crie uma interface 'Forma' com um método 'calcularArea()'. Implemente as classes 'Circulo' e 'Quadrado' que implementam esta interface e seus métodos.",
        "dicas": ["Use a palavra-chave 'interface'", "Use 'implements' nas classes", "A área do círculo é PI * raio * raio", "A área do quadrado é lado * lado"],
        "variaveisObrigatorias": ["Forma circulo", "Forma quadrado"],
        "palavrasChave": ["interface", "implements", "polimorfismo", "Math.PI"],
        "templateCodigo": "interface Forma {\n    double calcularArea();\n}\n\n// Implemente as classes Circulo e Quadrado aqui\n\npublic class TesteFormas {\n    public static void main(String[] args) {\n        Forma f1 = new Circulo(5.0);\n        Forma f2 = new Quadrado(4.0);\n        System.out.println(\"Área do Círculo: \" + f1.calcularArea());\n        System.out.println(\"Área do Quadrado: \" + f2.calcularArea());\n    }\n}",
        "pontos": 85
    },
    {
        "id": 5,
        "nivel": "intermediario",
        "categoria": "poo",
        "titulo": "Sobrecarga de Métodos",
        "descricao": "Crie uma classe 'Calculadora' com dois métodos 'somar', um para somar dois inteiros e outro para somar dois doubles.",
        "dicas": ["Os métodos devem ter o mesmo nome", "As assinaturas (parâmetros) devem ser diferentes", "Um retorna int, o outro retorna double"],
        "variaveisObrigatorias": ["int somar(int, int)", "double somar(double, double)"],
        "palavrasChave": ["sobrecarga", "overloading", "assinatura"],
        "templateCodigo": "public class Calculadora {\n    // Método somar para inteiros\n\n    // Método somar para doubles\n\n    public static void main(String[] args) {\n        Calculadora calc = new Calculadora();\n        System.out.println(calc.somar(5, 3));\n        System.out.println(calc.somar(5.5, 3.2));\n    }\n}",
        "pontos": 90
    },
    {
        "id": 6,
        "nivel": "intermediario",
        "categoria": "poo",
        "titulo": "Membros Estáticos",
        "descricao": "Crie uma classe 'Contador' com um atributo estático 'instancias' que incrementa a cada novo objeto criado. Adicione um método estático para obter o número de instâncias.",
        "dicas": ["Use a palavra-chave 'static' para o atributo e o método", "Incremente o contador no construtor", "O método estático é chamado a partir da classe: Contador.getInstancias()"],
        "variaveisObrigatorias": ["static int instancias", "static int getInstancias()"],
        "palavrasChave": ["static", "construtor", "classe"],
        "templateCodigo": "public class Contador {\n    // Atributo estático\n\n    public Contador() {\n        // Incrementar o contador\n    }\n\n    // Método estático\n\n    public static void main(String[] args) {\n        new Contador();\n        new Contador();\n        System.out.println(Contador.getInstancias()); // Deve imprimir 2\n    }\n}",
        "pontos": 95
    },
    {
        "id": 7,
        "nivel": "avancado",
        "categoria": "poo",
        "titulo": "Classe Abstrata",
        "descricao": "Crie uma classe abstrata 'Funcionario' com um método abstrato 'calcularSalario()'. Crie as classes 'Gerente' e 'Programador' que herdam de Funcionario e implementam o método.",
        "dicas": ["Use 'abstract class' e 'abstract void'", "Classes concretas devem usar 'extends' e implementar o método", "Classes abstratas não podem ser instanciadas"],
        "variaveisObrigatorias": ["abstract class Funcionario", "abstract double calcularSalario()"],
        "palavrasChave": ["abstract", "extends", "implementar"],
        "templateCodigo": "abstract class Funcionario {\n    public abstract double calcularSalario();\n}\n\n// Crie as classes Gerente e Programador aqui\n\npublic class TesteFuncionarios {\n    public static void main(String[] args) {\n        Funcionario g = new Gerente();\n        Funcionario p = new Programador();\n        System.out.println(g.calcularSalario());\n        System.out.println(p.calcularSalario());\n    }\n}",
        "pontos": 100
    },
    {
        "id": 8,
        "nivel": "avancado",
        "categoria": "poo",
        "titulo": "Palavra-chave final",
        "descricao": "Crie uma classe 'Configuracao' com uma constante 'URL_BANCO_DE_DADOS' (final) e um método 'conectar()' que não pode ser sobrescrito (final).",
        "dicas": ["Use 'public static final String ...' para constantes", "Use 'public final void ...' para métodos que não podem ser sobrescritos"],
        "variaveisObrigatorias": ["final String URL_BANCO_DE_DADOS", "final void conectar()"],
        "palavrasChave": ["final", "constante", "sobrescrita"],
        "templateCodigo": "public class Configuracao {\n    // Crie a constante final aqui\n\n    // Crie o método final aqui\n\n}",
        "pontos": 105
    },
    {
        "id": 9,
        "nivel": "avancado",
        "categoria": "poo",
        "titulo": "Composição",
        "descricao": "Crie uma classe 'Motor'. Crie uma classe 'Carro' que tem um 'Motor' (composição). O Carro deve ter um método para ligar o motor.",
        "dicas": ["A classe Carro deve ter um atributo do tipo Motor", "Instancie o Motor dentro do construtor do Carro", "O método do Carro chama um método do Motor"],
        "variaveisObrigatorias": ["Motor motor", "Carro carro"],
        "palavrasChave": ["composição", "tem-um", "objeto"],
        "templateCodigo": "class Motor {\n    public void ligar() {\n        System.out.println(\"Motor ligado!\");\n    }\n}\n\nclass Carro {\n    // Atributo de composição\n\n    public Carro() {\n        // Instancie o motor\n    }\n\n    // Método para ligar o motor\n}\n\npublic class TesteComposicao {\n    public static void main(String[] args) {\n        Carro meuCarro = new Carro();\n        meuCarro.ligarMotor();\n    }\n}",
        "pontos": 110
    },
    {
        "id": 10,
        "nivel": "intermediario",
        "categoria": "poo",
        "titulo": "Enumeração",
        "descricao": "Crie uma enumeração 'Naipe' para um baralho (PAUS, OUROS, COPAS, ESPADAS) com um atributo para a cor (preto ou vermelho).",
        "dicas": ["Use 'public enum Naipe { ... }'", "Adicione um construtor e um atributo à enumeração", "Os valores da enum são definidos como: COPAS(\"vermelho\")"],
        "variaveisObrigatorias": ["enum Naipe", "String cor"],
        "palavrasChave": ["enum", "constantes", "atributo"],
        "templateCodigo": "public enum Naipe {\n    // Defina os naipes e suas cores aqui\n\n    private final String cor;\n\n    Naipe(String cor) {\n        this.cor = cor;\n    }\n\n    public String getCor() {\n        return cor;\n    }\n}\n\npublic class TesteEnum {\n    public static void main(String[] args) {\n        System.out.println(Naipe.COPAS.getCor()); // Deve imprimir vermelho\n    }\n}",
        "pontos": 90
    },
    {
        "id": 11,
        "nivel": "avancado",
        "categoria": "poo",
        "titulo": "Herança com Interfaces",
        "descricao": "Crie uma classe 'Pato' que herda de 'Animal' e implementa as interfaces 'Voador' e 'Nadador'.",
        "dicas": ["Uma classe pode herdar de uma classe e implementar múltiplas interfaces", "Use 'extends Animal implements Voador, Nadador'"],
        "variaveisObrigatorias": ["extends Animal", "implements Voador, Nadador"],
        "palavrasChave": ["herança", "interface", "múltipla"],
        "templateCodigo": "class Animal { }\ninterface Voador { void voar(); }\ninterface Nadador { void nadar(); }\n\n// Crie a classe Pato aqui\n\npublic class TestePato {\n    public static void main(String[] args) {\n        Pato p = new Pato();\n        p.voar();\n        p.nadar();\n    }\n}",
        "pontos": 115
    },
    {
        "id": 12,
        "nivel": "mestre",
        "categoria": "poo",
        "titulo": "Padrão Singleton",
        "descricao": "Implemente o padrão Singleton para uma classe 'GerenciadorDeConexao', garantindo que apenas uma instância da classe possa ser criada.",
        "dicas": ["Crie um construtor privado", "Crie um atributo estático privado para a única instância", "Crie um método estático público para obter a instância"],
        "variaveisObrigatorias": ["private static GerenciadorDeConexao instancia", "private GerenciadorDeConexao()", "public static GerenciadorDeConexao getInstancia()"],
        "palavrasChave": ["singleton", "padrão de projeto", "instância única"],
        "templateCodigo": "public class GerenciadorDeConexao {\n    // Atributo estático para a instância\n\n    // Construtor privado\n\n    // Método público para obter a instância\n\n}\n\npublic class TesteSingleton {\n    public static void main(String[] args) {\n        GerenciadorDeConexao con1 = GerenciadorDeConexao.getInstancia();\n        GerenciadorDeConexao con2 = GerenciadorDeConexao.getInstancia();\n        System.out.println(con1 == con2); // Deve imprimir true\n    }\n}",
        "pontos": 125
    },
    {
        "id": 13,
        "nivel": "intermediario",
        "categoria": "poo",
        "titulo": "Sobrescrita do toString()",
        "descricao": "Na classe 'Carro' do exercício 1, sobrescreva o método toString() para retornar uma representação em string do objeto (ex: \"Marca: Ford, Modelo: Ka, Ano: 2020\").",
        "dicas": ["Use a anotação @Override", "O método deve ter a assinatura 'public String toString()'", "Concatene os atributos para formar a string de retorno"],
        "variaveisObrigatorias": ["@Override", "public String toString()"],
        "palavrasChave": ["toString", "sobrescrita", "representação"],
        "templateCodigo": "public class Carro {\n    String marca, modelo;\n    int ano;\n\n    public Carro(String marca, String modelo, int ano) {\n        this.marca = marca;\n        this.modelo = modelo;\n        this.ano = ano;\n    }\n\n    // Sobrescreva o método toString() aqui\n\n    public static void main(String[] args) {\n        Carro meuCarro = new Carro(\"Ford\", \"Ka\", 2020);\n        System.out.println(meuCarro);\n    }\n}",
        "pontos": 95
    },
    {
        "id": 14,
        "nivel": "avancado",
        "categoria": "poo",
        "titulo": "instanceof com Polimorfismo",
        "descricao": "Em um array de 'Forma' (exercício 4), use 'instanceof' para contar quantos Círculos e quantos Quadrados existem no array.",
        "dicas": ["Percorra o array com um loop for-each", "Use 'if (forma instanceof Circulo)' para verificar o tipo", "Incremente contadores separados para cada tipo"],
        "variaveisObrigatorias": ["instanceof Circulo", "instanceof Quadrado"],
        "palavrasChave": ["instanceof", "polimorfismo", "casting"],
        "templateCodigo": "interface Forma { }\nclass Circulo implements Forma { }\nclass Quadrado implements Forma { }\n\npublic class ContadorDeFormas {\n    public static void main(String[] args) {\n        Forma[] formas = {new Circulo(), new Quadrado(), new Circulo()};\n        int numCirculos = 0;\n        int numQuadrados = 0;\n\n        // Use instanceof para contar as formas\n\n        System.out.println(\"Círculos: \" + numCirculos);\n        System.out.println(\"Quadrados: \" + numQuadrados);\n    }\n}",
        "pontos": 110
    }
]